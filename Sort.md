# Алгоритмы сортировки

Алгоритм — пошаговая инструкция.

## Пузырьковая сортировка

Один из самых простых и известных алгоритмов. Он работает следующим образом:

1. Сравниваются два соседних элемента
2. Если порядок элементов неправильный, они меняются местами
3. Процесс повторяется до тех пор, пока все элементы списка не будут отсортированы

### Пример реализации:

```swift
import UIKit

class BubbleSort {
    func sort(_ array: [Int]) -> [Int] {
        var arr = array
        let n = arr.count
        for i in 0..<n-1 {
            for j in 0..<n-i-1 {
                if arr[j] > arr[j+1] {
                    // меняем местами
                    let temp = arr[j]
                    arr[j] = arr[j+1]
                    arr[j+1] = temp
                }
            }
        }
        return arr
    }
}

let bubbleSort = BubbleSort()
bubbleSort.sort([5, 4, 3, 2, 1])
```
## Особенности:

- Два вложенных цикла for

## Оценка скорости алгоритма: O(n²) (квадратичный, довольно медленно)

## Сортировка слиянием
- Алгоритм разбивает массив на более мелкие части, сортирует их, а затем объединяет (сливает) обратно, чтобы получить отсортированный массив.

## Процесс:
- Разделение - массив рекурсивно делится пополам, пока не получится набор массивов, каждый из которых содержит только один элемент (такие массивы по умолчанию считаются отсортированными)
- Слияние - пары отсортированных массивов объединяются в один, более крупный отсортированный массив
- Слияние обратно - на каждом уровне рекурсии отсортированные части объединяются в один массив, сохраняя порядок элементов
## Пример реализации:
```swift
import Foundation

func mergeSort<T: Comparable>(_ list: [T]) -> [T] {
    // если в нашем массиве больше, чем один элемент, то имеет смысл его сортировать
    if list.count > 1 {
        
        // находим средний элемент
        let mid = list.count / 2
        // делим массив на левую часть и правую
        let leftPart = Array(list[0..<mid])
        let rightPart = Array(list[mid...])
        
        // разделяем массив до тех пор пока это возможно
        var dividedLeft = mergeSort(leftPart)
        var dividedRight = mergeSort(rightPart)
        
        // массив уже "слитых" элементов
        var merged = [T]()
        
        // сравниваем разделённые части и "сливаем" в правильном порядке
        while dividedLeft.count > 0 && dividedRight.count > 0 {
            if dividedLeft.first! < dividedRight.first! {
                merged.append(dividedLeft.removeFirst())
            } else {
                merged.append(dividedRight.removeFirst())
            }
        }
        return merged + dividedLeft + dividedRight
        
    } else {
        return list
    }
}
```
## Оценка скорости алгоритма: O(n log n) (не так уж плохо)
